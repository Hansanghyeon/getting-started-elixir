# 짧은 헤렆 함수를 만드는 전략은 너무 흔해서 엘릭서에서도 단축 문법을 지원한다.
# 먼저 실제 사용법을 확인하자.

add_one = &(&1 + 1) # add_one = fn (n) -> n + 1 end 와 같다.
IO.puts add_one.(44) # => 45

square = &(&1 * &1)
IO.puts square.(12) # => 144

speak = &(IO.puts(&1))
speak.("Hello") # => Hello

# 이 방식이 꽤 똑똑해보인다면, 한발 더 나아가 코드에서 speak를 정의하는 부분을 살펴보자.
# 일반적으로 엘릭서가 익명 함수를 만드는 방식을 생각하면 `&(IO.puts(&1))`은 `fn x -> IO.puts(x) end`로 바뀔것이다.
# 그런데 이렇게 정의되는 익명 함수는 그저 기명 함수 (IO 모듈의 puts 함수)를 호출하고 있고
# 파라미터의 순서도 같다(다시 말해, 익명 함수의 첫 번째 파라미터가 기명 함수의 첫 번째 파라미터가 되는 식이다).
# 이 경우 엘릭서는 익명 함수를 최적화해 직업 `IO.puts/1` 함수를 참조하도록 한다. 이렇게 최적화되려면 인자가 같은 순서로 들어가야한다.

rnd = &(Float.round(&1, &2))
rnd = &(Float.round(&2, &1))

# 이런식으로 함수를 정의하다 보면 얼랭의 요소를 참조하게 되는 경우가 있다.
# 이는 엘릭서가 얼랭 VM위에서 동작한다는 증거다. `&abs(&1)`과 같은 입력하면 역시 얼램 함수의 참조인 `&:erlang.abs/1`이 반환되는데
# 이는 엘릭서가 abs 함수 호출을 직접 얼랭 라이브러리에 매핑하기 때문이다.

# 엘릭서에서는 []과 {}이 연산자이므로 리스트와 튜플 리터럴도 함수가 될 수 있다. 다음 함수는 두 정수를 나누어서 몫과 나머지로 이루어진 튜플을 반환한다.

divrem = &{ div(&1, &2), rem(&1, &2) }
IO.inspect divrem.(13, 5) # => {2, 3}

# 마지막으로 `&` 캡처 연산자는 문자열과 관련된 리터럴에서도 동작한다.

s = &"bacon and #{&1}"
IO.puts s.("eggs") # => bacon and eggs

match_end = &~r/.*#{&1}$/
# ? 여기서 =~는 무엇을 의미하는가?
# `=~` 는 Elixir에서 정규 표현식을 매칭하는 연산자입니다. 이 연산자는 왼쪽 피연산자가
# 정규표현식에 매칭되는지 확인하고, 매칭되면 매칭된 결과를 반환합니다. 예를 들어
# "hello world" =~ ~r/world/ 는 true를 반환합니다.
"cat" =~ match_end.("t")
