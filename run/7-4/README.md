# 맵 함수 만들기

`square`와 `add_1` 모두 실제 연산은 함수의 두 번째 정의에서 이루어졌다. 그리고 그 정의도 거의 비슷한 내용이었다. 둘 다 새로운 리스트를 반환했는데, 새로운 리스트의 머리 부분은 인자의 머리의 값을 제곱하거나 1을 더한 결과였고, 꼬리 부분은 인자의 꼬리를 새로운 인자로 한 재귀 호출의 결과였다. 이 동작을 일반화해 map이라는 함수를 새로 정의해보자. 이 함수는 리스트와 함수를 받아 새로운 리스트를 반환하는데, 반환되는 리스에는 인자로 받은 함수를 원본 리스트의 각 요소에 적용한 결과를 담는다.

```exs
def map([], _func), do: []
def map([ head | tail ], func), do: [ func.(head) | map(tail, func) ]
```

map 함수는 square, add_1 함수와 거의 동일하다. 빈 리스트를 받으면 빈 리스트를 반환한다. 그렇지 않으면 새로운 리스트를 반환하는데, 리스트의 머리는 인자로 받은 함수를 적용한 값이고, 꼬리는 같은 함수를 재귀 호출한 결과다. 빈 리스트에 대한 함수 구현에서는 인자로 받은 함수를 사용하지 않으므로 두 번째 파라미터의 이름에 `_func`와 같이 언더스코어를 붙였다. 언더스코어를 사용하면 변수가 사용되지 않았을 때 발생하는 경고를 제거해준다. 리스트와 함수(fn으로 정의할 수 있다)를 전달해 함수를 호출해보자.

```sh
iex> c "mylist1.exs"
[MyList]
iex> MyList.map [1,2,3,4], fn (n) -> n*n end
[1, 4, 9, 16]
```

함수 역시 기본 내장 자료형으로, fn과 end 사이에 본문을 넣어 정의한다. 이렇게 정의한 함수는 map 함수의 두 번째 인자(func)가 되고, map 함수 안에서 `func.(head)`와 같이 호출된다. 그러면 head의 값이 제곱이 되어 새 리스트에 들어간다. map에 다른 함수를 넣어 호출해보자.

```sh
iex> MyList.map [1,2,3,4], fn (n) -> n+1 end
[2, 3, 4, 5]
```

& 표기법으로도 같은 동작을 구현할 수 있다.

```sh
iex> MyList.map [1,2,3,4], &(&1 + 1)
```