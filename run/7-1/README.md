# 리스트의 머리와 꼬리

리스트는 비어있거나 머리와 꼬리로 구성되어 있다. 머리는 값을 담고, 꼬리는 머리를 제외한 나머지 값을 담은 리스트다. 이는 리스트의 재귀적 정의다. 빈 리스트는 다음과 같이 쓴다.

```
[]
```

파이프 기호 ( | )를 사용해서 리스트의 머리와 꼬리 사이를 구분할 수 있다고 상상해보자. 우리가 흔이 `[ 3 ]`과 같이 쓰는 값 하나짜리 리스트는, 3이라는 값이 빈 리스트와 이어져 있는 것처럼 바꾸오 쓸 수 있다

```
[ 3 | [] ]
```

파리프 기호 왼쪽에 있는 값을 리스트의 머리라고 하고, 오른쪽 리스트의 꼬리라고 하자. 리스트 `[2, 3 ]`에서 머리는 2고 꼬리는 ㄱ밧 하나짜리 리스트`[3]`다. 그런데 꼬리에 해당하는 리스트는 바로 앞 예제에서 봤다. `[2, 3]`은 다음 처럼 쓸 수도 있다.

```
[ 2 | [ 3 | [] ]]
```

리스트에 값을 하나 추가해 `[1, 2, 3]`을 만들자. 이 리스트는 머리가 1이고 그 뒤에 `[2, 3]`이 이어지는데, 뒤에 이어지는 리스트는 바로 앞에서도 봤다.

```
[ 1 | [ 2 | [3 | [] ]]]
```

놀랍게도 이 표기는 유효한 엘릭서 문법이다. IEx에 그대로 입력해 보자.

```sh
iex> [ 1 | 2 | [ 3 | [] ]]
[1, 2, 3]
```

그리고 여기서 마법이 시작된다. 패턴매칭을 다루면서, 패턴에 리스트도 사용할 수 있으며 이때 우변에 있는 리스트의 값이 좌변으로 할당됨을 살펴봤다.

```sh
iex> [a, b, c] = [1, 2, 3]
[1, 2, 3]
iex> a
1
iex> b
b
iex> c
3
```

한발 더 나아가 파이프 기호를 패턴에 사용할 수도 있다. 파이프 기호 왼쪽에는 리스트의 머리 부분이 매칭되고, 오른쪽에는 꼬리 부분이 매칭된다.

```sh
iex> [ head | tail ] = [1, 2, 3]
[1, 2, 3]
iex> head
1
iex> tail
[2, 3]
```
