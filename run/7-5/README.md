# 리스트를 줄여 하나의 값으로 만들기

방금 만든 `map/2` 함수는 리스트의 각 요소에 독립적으로 함수를 적용하는 개념을 추상화한 것이다. 그렇다면 함수를 요소마다 적용하는 것이 아니라 여러 요소에 걸쳐 적용하고 싶을 때는 어떻게 할까? 리스트의 있는 값을 모두 더하거나. 곱하거나 또는 리스트에서 가장 큰 값을 찾아내는 작업은 어떻게 추상화할까?

컬렉션의 모든 값을 더하는 sum 함수는 컬렉션을 줄여(reduce) 하나의 값으로 만든다. 걸렉션에서 가장 크거나 작은 값을 찾거나, 각 요소를 곱하거나, 모든 문자열을 합치는 함수도 마찬가지다. 그렇다면 컬렉션을 하나의 값으로 줄이는 일반화된 함수는 어떻게 만들까?

일단 컬렉션을 받아야 한다. 초기값도 필요하다(sum/1 함수는 0을 초기값으로 받게 된다). 또 한 함수도 하나 있어야 하는데, 이 함수는 현재까지의 누적된 연산 결과(컬렉션의 앞부분을 하나의 값으로 줄인 결과)와 컬렉션의 다음 값을 받아 연산의 다음 결과를 반환한다. 따라서 우리가 만들 reduce 함수는 다음처럼 인자 세 개를 받는다.

```exs
reduce(collection, initial_value, func)
```

이제 이 함수를 재귀적으로 설계해보자.

- `reduce([ ], value, _value) -> value`
- `reduce([ head | tail ], value, func) -> reduce(tail, fun(head, value) ,fun)`

reduce 함수는 리스트의 머리와 연산의 현재 값에 함수를 적용한다. 그리고 리스트의 꼬리에 reduce 연산을 적용할 때 그 연산 결과를 새로운 현재 값으로 전달한다. 다음 코드는 reduce 함수의 구현이다. 앞서 본 재귀적 설계를 잘 따르는지 확인하자.

당연하지만 함수를 전달할 때 & 표기법도 사용할 수 있다.

```exs
iex> c "reduce.exs"
[MyList]
iex> MyList.reduce([1,2,3,4,5], 0, &(&1 + &2))
15
iex> MyList.reduce([1,2,3,4,5], 1, &(&1 * &2))
120
```