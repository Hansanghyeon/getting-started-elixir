# 처음배우는 엘릭서 프로그래밍

## 2.2 더 복잡한 매칭

a는 현재 1을 바인딩하고, 3를 바인딩하려고 시도한다.
하지만 변수는 매칭당 한 번씩만 바인딩된다.
[a, b, a] = [1, 2, 3]
[a, b, a] = [1, 1, 2]

```elixir
[a, b, a] = [1, 2, 1]

IO.puts(b)
# b = 2
```

## 2.3 언더스코어로 값 무시하기

매칭은 하되 값을 변수데 담지 않아도 되는 경우 언더스코어(_)라는 특수한 변수를 사용할 수 있다. 언더스코어는 변수처럼 동작하지만 주어진 값을 그 즉시 버린다. 패턴 매칭에서는 모든 값을 받아들이는 와일드 카드로 사용할 수있다. 다음 예제에서 사용하는 패턴은 길이가 3이고 첫 번째 값이 1인 모든 리스트에 매칭된다.

```elixir
[1, _, _] = [1, 2, 3]
# [1, 2, 3]
[1, _, _] = [1, "cat", "dog"]
# [1, "cat", "dog"]
```

## 5. 익명함수

이 장에서 살펴볼 내용은 다음과 같다.

* 익명 함수
* 인자 패턴 매칭
* 고계 함수
* 클로저
* & 함수 리터럴

엘릭서는 함수형 언어이므로 함수가 기본 타입이라는 것이 그리 놀라운 일은 아니다. fn 키워드로 익명 함수를 만들 수 있다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
fn
  parameter - list -> body
  parameter - list -> body(...)
end
```

`fn...end`를 문자열 리터럴을 감싸는 따옴표 같은 것이라고 여기되, 문자열 대신 함수를 반환하는 문법이라고 생각해보자. 우리는 어떻게 만든 '함수'라는 값을 다른 함수에 전달할 수있다. 당연히 함수에 인자를 넣어 호출할 수도 있다.

함수는 기본적으로 파라미터 목록과 함수 본문을 가지며, 둘은 `->` 기호로 구분된다. 예를 들어보자. 다음 코드는 함수를 정의한 뒤 `sum`이라는 변수에 바인딩하고, 그 함수를 호출한다.

```elixir
sum = fn a, b -> a + b end
sum.(1, 2)
```

첫 번째 줄에서 a와 b라는 두 파라미터를 받는 함수를 만들었다. 함수 구현은 `->` 기호 뒤에 이어진다(예시에서는 파라미터로 받은 a와 b를 더하는 간단한 연산이다). `end` 키워드로 구현을 끝내고, 이렇게 만든 함수를 `sum`변수에 저장했다.

코드의 둘때 줄에서는 `sum.(1,2)`로 함수를 호출했다. 온점(.)을 사용해 함수를 호출하고, 괄호 안에 인자를 넣어 전달할 수 있다(나중에 살펴보겠지만 익명 함수와 기명 함수는 호출 방법이 각각 다르다. 기명함수를 호출할 때는 온점을 사용하지 않는다). 익명 함수에서는 함수가 인자를 받지 않더라도 괄호를 사용해 호출해야 한다.

```elixir
greet = fn -> IO.puts("Hello") end
greet.()
```

하지만 함수를 정의할 떄 괄호가 필요하지 않다.

```elixir
f1 = fn a, b -> a * b end
IO.puts(f1.(5, 6))
f2 = fn -> 99 end
IO.puts(f2.())
```

## 5.1 함수와 패턴 매칭

`sum.(2,3)`을 호출하면 2를 a에 할당하고, 3을 b에 할당한다는 것을 쉽게 예상할 수 있다. 하지만 우리는 '할당'이라는 단어를 경계해야 한다. 엘릭서에는 할당문이 없다. 대신 값을 패턴에 매칭하려 한다(패턴 매칭과 할당에 관해서는 2장에서 살펴봤다.) 예를 들어 다음과 같은 코드가있다고 하자.

```elixir
a = 2
```

엘릭서에서는 2라는 값을 변수 a에 바인딩해 패턴 매칭한다. 이 과정은 sum함수가 호출될 떄도 동일하게 실행된다. 2와 3을 인자로 전달하면 인자는 파라미터 a,b에 패턴 매칭된다. 이 과정에서 a에 2가, b에 3이 들어간다. 다음과 동일한 것으로 볼 수 있다.

```elixir
{a, b} = {2, 3}
```

이는 함수를 호출할 때 패턴 매칭의 특성을 이용해 더 복잡한 매칭을 할 수도 있음을 의미한다. 예컨대 패턴 매칭을 이용해 다음과 같이 튜플의 순서를 뒤집을 수도 있다.

```elixir
swap = fn {a, b} -> {b, a} end
swap.({6, 8})
# {8, 6}
```

다음 절에서 구현이 여러 개인 함수를 알아보며 이 패턴 매칭 기능을 다시 사용해보자.

### 연습문제

다음과 같이 동작하는 함수를 만들어 실행해보자.

```
list_concat.([:a, :b], [:c, :d])
# => [:a, :b, :c, :d]
```

```elixir
list_concat = fn list1, list2 -> list1 ++ list2 end
result = list_concat.([:a, :b], [:c, :d])
```

```
sum.(1, 2, 3)
# => 6
```

```elixir
sum = fn a, b, c -> a + b + c end
result = sum.(1, 2, 3)
```

```
pair_tuple_to_list.({ 1234, 5678 })
# => [1234, 5678]
```

```elixir
ExUnit.start()

pair_tuple_to_list = fn tuple -> Tuple.to_list(tuple) end
# 아직 배우지 않은 방법
# Tuple.to_list는 튜플을 리스트로 변환하는 함수이다.
result = pair_tuple_to_list.({1234, 5678})
pair_tuple_to_list = fn {a, b} -> [a, b] end
result = pair_tuple_to_list.({1234, 5678})

defmodule ExTest do
  use ExUnit.Case

  test "pair_tuple_to_list.({ 1234, 5678 })
# => [1234, 5678]" do
    assert MyList.mapsum([1, 2, 3], &(&1 * &1)) == 14
  end

  test "iex> MyList.max([1,2003,3,4,102]) # 2003" do
    assert MyList.max([1, 2003, 3, 4, 102]) == 2003
  end
end
```

## 5.2 함수는 하나, 본문은 여러개

문자열 내에 표현식을 삽입하는 방법은 `#{...}`을 사용해 표현식을 넣으면, 코드가 계산되어 그 실행 결과로 문자열이 대체된다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
handle_open = fn
  {:ok, file} -> "First line: #{IO.read(file, :line)}"
  {_, error} -> "Error: #{:file.format_error(error)}"
end

# 존재하는 파일을 연다.
IO.puts(handle_open(File.open("Rakefile.bin")))
# 존재하지 않는 파일을 연다.
IO.puts(handle_open(File.open("nonexistent")))
```

livebook에서 파일을 오픈하는 방법은 아직 잘 모르겠다.

## 5-4

문자열을 받는 prefix 함수를 만들어보자. 이 함수는 다른 문자열을 받는 새로운 함수를 반환하고, 두 번째 함수를 호출하면 첫 번째 문자열과 두 번째 문자열을 공백으로이은 문자열을 반환해야 한다.

```elixir
prefix = fn prefix -> fn str -> "#{prefix} #{str}" end end
mrs = prefix.("Elixir")
IO.puts(mrs.("Rocks"))
```

### 5.4.1 함수 파라미터 고정하기

패턴 매칭에서 살펴봤듯, 핀 연산자(^)는 패턴 안에 있는 변수에 변수의 현재 값을 사용하도록 해준다.
함수 파라미터에도 이 연산자를 사용할 수 있다.

```elixir
defmodule Greeter do
  def for(name, greeting) do
    fn
      ^name -> "#{greeting} #{name}"
      _ -> "I don't know you"
    end
  end
end

mr_vlim = Greeter.for("Mr Vlim", "Hello")

# => "Hello Mr Vlim"
IO.puts(mr_vlim.("Mr Vlim"))
# => "I don't know you"
IO.puts(mr_vlim.("Dave"))
```

여기서 `Greeter.for` 함수는 두 개의 구현을 가진 함수를 반환한다.
내부 함수를 호출할 떄의 파라미터가 외부 함수인 for에 전달된 name의 값과 같을 때 첫 번째 구현에 매치된다.

### 5.4.2 표기법

짧은 헬퍼 함수를 만드는 전략은 너무 흔해서 엘릭서에서도 단축 문법을 지원한다.
먼저 실제 사용법을 확인하자.

```elixir
# add_one = fn (n) -> n + 1 end 와 같다.
add_one = &(&1 + 1)
# => 45
IO.puts(add_one.(44))
```

```elixir
square = &(&1 * &1)
# => 144
IO.puts(square.(12))
```

```elixir
speak = &IO.puts(&1)
# => Hello
speak.("Hello")
```

이 방식이 꽤 똑똑해보인다면, 한발 더 나아가 코드에서 speak를 정의하는 부분을 살펴보자.

일반적으로 엘릭서가 익명 함수를 만드는 방식을 생각하면 `&(IO.puts(&1))`은 `fn x -> IO.puts(x) end`로 바뀔것이다.

그런데 이렇게 정의되는 익명 함수는 그저 기명 함수 (IO 모듈의 puts 함수)를 호출하고 있고 파라미터의 순서도 같다(다시 말해, 익명 함수의 첫 번째 파라미터가 기명 함수의 첫 번째 파라미터가 되는 식이다).

이 경우 엘릭서는 익명 함수를 최적화해 직업 `IO.puts/1` 함수를 참조하도록 한다. 이렇게 최적화되려면 인자가 같은 순서로 들어가야한다.

```elixir
rnd = &Float.round(&1, &2)
rnd = &Float.round(&2, &1)
```

이런식으로 함수를 정의하다 보면 얼랭의 요소를 참조하게 되는 경우가 있다.

이는 엘릭서가 얼랭 VM위에서 동작한다는 증거다. `&abs(&1)`과 같은 입력하면 역시 얼램 함수의 참조인 `&:erlang.abs/1`이 반환되는데

이는 엘릭서가 abs 함수 호출을 직접 얼랭 라이브러리에 매핑하기 때문이다.

엘릭서에서는 []과 {}이 연산자이므로 리스트와 튜플 리터럴도 함수가 될 수 있다. 다음 함수는 두 정수를 나누어서 몫과 나머지로 이루어진 튜플을 반환한다.

```elixir
divrem = &{div(&1, &2), rem(&1, &2)}
# => {2, 3}
IO.inspect(divrem.(13, 5))
```

마지막으로 `&` 캡처 연산자는 문자열과 관련된 리터럴에서도 동작한다.

```elixir
s = &"bacon and #{&1}"
# => bacon and eggs
IO.puts(s.("eggs"))
```

`match_end = &~r/.*#{&1}$/`

`?` 여기서 `=~`는 무엇을 의미하는가?
`=~` 는 Elixir에서 정규 표현식을 매칭하는 연산자입니다. 이 연산자는 왼쪽 피연산자가
정규표현식에 매칭되는지 확인하고, 매칭되면 매칭된 결과를 반환합니다. 예를 들어
`"hello world" =~ ~r/world/` 는 true를 반환합니다.

`"cat" =~ match_end.("t")`

```elixir
ExUnit.start()

# 다음 코드를 & 표기법을 사용하도록 고쳐보자
# Enum.map [1, 2, 3, 4], fn x -> x + 2 end
# Enum.each [1, 2, 3, 4], fn x -> IO.inspect x end

defmodule Ex55Test do
  use ExUnit.Case

  test "1번문제" do
    result = Enum.map([1, 2, 3, 4], &(&1 + 2))
    assert result == [3, 4, 5, 6]
  end

  test "2번문제" do
    result = Enum.each([1, 2, 3, 4], &IO.inspect/1)
    assert result == :ok
  end
end
```

## 5.5 함수는 엘릭서의 핵심이다.

이 책을 시작할 때 프로그래밍의 기본은 데이터를 변형하는 것이라고 소개했다. 함수는 그 변형을 수행하는 자그마한 엔진이다. 함수는 엘릭서의 핵심에 자리잡고 있다.

지금까지 익명 함수를 살펴봤다. 익명 함수는 변수에 바인디해서 사용할 수 있지만, 함수 자체에는 이름이 없다. 물론 엘릭서에는 이름을 가진 기명 함수도 있다. 다음 장에서 기명 함수를 어떻게 사용하는지 알아보자.

## 6 모듈과 기명함수

이 장에서 살펴볼 내용은 다음과 같다.

* 코드의 기본 단위인 모듈
* 퍼블릭, 프라이빗 기명 함수의 정의
* 가드 조건절
* 모듈 지시자(directive)와 모듈 속성
* 얼랭 모듈의 함수 호출하기

프로그램이 어느 정도 커지면 코드를 일정한 구조로 정리하고 싶어질 것이다. 엘릭서에서는 쉽게 여러 **기명 함수(named function)**로 코드를 나누고, 이 함수들을 **모듈(module)**로 묶어 정리할 수 있다. 사실 엘릭서에서의 기명 함수는 항상 모듈 내에서만 정의할 수 있다.

```elixir
defmodule Times do
  def double(n) do
    n * 2
  end
end

IO.puts(Times.double(10))
# 20
```

`Times`라는 모듈을 정의하고 그 안에 `double`이라는 함수를 하나 두었다. 엘릭서에서는 함수를 식별하는 요소 중 하나로 인자의 갯수를 사용하는데, 이 함수는 인자를 하나 받으므로 함수를 가리킬 때는 `double/1`로 쓸 수 있다.

## 6.1 모듈 컴파일하기

에제 파일을 컴파일해서 IEx에 로드하는 방법에는 두 가지가 있다. 첫 번째 방법은 명령줄에서 다음과 같이 입력하는 것이다.

```sh
iex times.exs
iex> Times.double(4)
8
```

IEx를 실행할 때 소스 코드가 있는 파일의 이름을 지정하면 IEx는 입력 프롬프트를 띄우기 전에 해당 파일을 컴파일해서 로드해둔다. 이미 IEx가 실행 중인 경우에는 c 헬퍼 함수를 이용해 명령줄로 나가지 않더라도 파일을 컴파일할 수 있다.

```sh
iex> c "itmes.exs"
[Times]
iex> Times.double(4)
8
iex> Times.double(123)
246
```

c "times.exs" 함수를 호출하면 소스 파일을 컴파일해 IEx로 로드한다. 그 뒤에는 Times.double을 입력해 Times 모듈에 있는 double 함수를 몇 번이든 호출할 수 있다. 함수를 실행할 때 숫자 대신 문자를 넣어 일부러 오류가 발생하도록 해보자. 어떤 일이 일어날까?

```sh
iex> Times.double("cat")
** (ArithmeticError) bad argument in arithmetic expression: "cat" * 2
    :erlang.*("cat", 2)
    times.exs:3: Times.double/1
    iex:1: (file)
```

ArithmeticError 예외가 발생하고 스택 트레이스가 출력된다. 오류 메시지의 첫째 줄은 무엇이 잘못되었는지(문자열에 대해 산술 연산을 하려 했다)를 나타낸다. 이어서 어디에서 문제가 발생했는지를 알 수 있다. 여기에서 함수 이름을 `Times.double/1`이라고 적은 데 주목하자.

엘릭서에서 기명 함수는 함수의 이름과 파라미터의 갯수로 식별된다. 우리가 만든 `double` 함수는 1개의 파라미터를 받으므로, 엘릭서는 이를 `double/1`로 식별한다. 만약 3개의 파라미터를 받는 다른 `double` 함수가 또 있다면, 이 함수는 `double/3`으로 식별된다. 적어도 엘릭서에서 두 함수는 완전히 별개다. 반면 우리는 파라미터 갯수가 다르더라도 이름이 같으면 관련 있는 함수로 생각하기 쉬우므로, 서로 관련이 없는 두 함수에는 같은 이름을 붙이지 않는 편이 좋다.

## 6.2 함수의 본문은 블록이다

`do...end` 블록은 여러 줄의 표현식을 한데 묶어 다른 코드로 전달하는 한 가지 방법이다. 이 방법은 모듈이나 기명 함수를 정의할 때, 제어 구조 등 코드를 하나의 개체로 다루어야 하는 모든 곳에서 사용된다. 그런데 `do...end`는 사실 엘릭서의 기본 문법이 아니다. 실제 문법은 다음과 같다.

```exs
def double(n), do: n * 2
```

여러 줄의 코드를 괄호로 묶어 `do:`의 값으로 전달할 수도 있다.

```exs
def greet(greeting, name), do: (
  IO.puts greeting
  IO.puts "How're you doing, #{name}?"
)
```

`do...end` 문법은 개발자의 편의를 위한 문법일 뿐이다. 컴파일 과정에서 `do...end`는 `do:` 형태로 바뀐다(`do:` 형태 자체는 키워드 리스트의 한 항목으로, 특별한 문법이 아니다). 일반적으로 한 줄 짜리 코드 블록에는 `do:`를, 여러 줄짜리 블록에는 `do...end`를 사용한다. 따라서 앞서 살펴본 times 예제를 다음처럼 고쳐 쓸 수도 있다.

```exs
defmodule Times do
  def double(n), do: n * 2
end
```

심지어 이렇게 쓸 수도 있다(할 수는 있지만 권장하지 않는다)

```exs
demodule Times, do: (def double(n), do: n * 2\)
```

## 6.3 함수 호출과 패턴 매칭

[5장](#5-1)에서 익명 함수를 알아보면서 파라미터를 실제 인자에 바인딩할 때 패턴 매칭이 어떻게 사용되는지 살펴봤다. 기명 함수에도 같은 규칙이 적용된다. 단, 하나의 기명 함수에 여러 구현을 정의할 떄는 각각의 파라미터와 본문을 가진 함수를 따로 작성해야 한다는 점이 다르다. 겉보기에는 서로 다른 함수를 여러 개 정의한 것처럼 보이지만 순수주의자들은 하나의 함수에 정의에 여러 개의 구현이 붙어 있는 것이라고 주장할 것이고. 그 말이 맞다.

기명 함수를 호출할 때 엘릭서는 첫 번째 함수 정의(구현)의 파라미터 목록에 인자가 매칭되는지 확인한다. 매칭되지 않는다면 같은 함수의 다음 정의에 매칭되는지 확인한다(이 함수 정의들이 받는 파라미터 갯수가 모두 같아야 함에 유의하자). 이 과정을 매칭되는 함수가 나타날 때까지, 또는 매칭할 함수가 다 떨어질 때까지 반복한다.

이 과정을 실험해보자. `n!`으로 쓰는 n 팩토리얼은 1부터 n까지의 자연수를 모두 곱한 값이다. `0!`은 1로 정의된다. 이 정의를 다른 방식으로 나나내면 다음과 같다.

```elixir
defmodule Factorial do
  def of(0), do: 1
  def of(n), do: n * of(n - 1)
end
```

하나의 함수에 대해 정의를 두 벌 만들었다. `Factorial.of(2)`를 호출하면 엘릭서는 2와 첫 번쨰 함수의 파라미터(0)를 매칭하려고 시도하는데, 이 시도는 실패한다. 이어서 두 번째 정의와 매칭을 시도하고, n에 2를 바인딩하면 매칭에 성공하므로 두 번째 정의의 본문이 실행된다. 본문에서 `Factorial.of(1)`을 호출하고, 이는 같은 과정에 따라 두 번째 정의에 매칭되어 실행된다. 이번에는 `Factorial.of(0)`이 호출되는데, 이는 첫 번째 정의에 매칭된다. 이 함수는 1을 반환하며 재귀를 종료한다. 엘릭서는 콜 스택을 거슬러 올라가며 곱셈을 수행한 뒤 최종 결과를 반환한다. 이 구현은 잘 동작하지만 개선의 여지가 많다. 나중에 꼬리 재귀를 알아보면서 개선하자.

```elixir
ExUnit.start()

defmodule Ex63Test do
  use ExUnit.Case

  test "0!" do
    assert Factorial.of(0) == 1
  end

  test "3!" do
    assert Factorial.of(3) == 6
  end

  test "7!" do
    assert Factorial.of(7) == 5040
  end

  test "10!" do
    assert Factorial.of(10) == 3_628_800
  end

  test "1000!" do
    assert Factorial.of(1000) ==
             402_387_260_077_093_773_543_702_433_923_003_985_719_374_864_210_714_632_543_799_910_429_938_512_398_629_020_592_044_208_486_969_404_800_479_988_610_197_196_058_631_666_872_994_808_558_901_323_829_669_944_590_997_424_504_087_073_759_918_823_627_727_188_732_519_779_505_950_995_276_120_874_975_462_497_043_601_418_278_094_646_496_291_056_393_887_437_886_487_337_119_181_045_825_783_647_849_977_012_476_632_889_835_955_735_432_513_185_323_958_463_075_557_409_114_262_417_474_349_347_553_428_646_576_611_667_797_396_668_820_291_207_379_143_853_719_588_249_808_126_867_838_374_559_731_746_136_085_379_534_524_221_586_593_201_928_090_878_297_308_431_392_844_403_281_231_558_611_036_976_801_357_304_216_168_747_609_675_871_348_312_025_478_589_320_767_169_132_448_426_236_131_412_508_780_208_000_261_683_151_027_341_827_977_704_784_635_868_170_164_365_024_153_691_398_281_264_810_213_092_761_244_896_359_928_705_114_964_975_419_909_342_221_566_832_572_080_821_333_186_116_811_553_615_836_546_984_046_708_975_602_900_950_537_616_475_847_728_421_889_679_646_244_945_160_765_353_408_198_901_385_442_487_984_959_953_319_101_723_355_556_602_139_450_399_736_280_750_137_837_615_307_127_761_926_849_034_352_625_200_015_888_535_147_331_611_702_103_968_175_921_510_907_788_019_393_178_114_194_545_257_223_865_541_461_062_892_187_960_223_838_971_476_088_506_276_862_967_146_674_697_562_911_234_082_439_208_160_153_780_889_893_964_518_263_243_671_616_762_179_168_909_779_911_903_754_031_274_622_289_988_005_195_444_414_282_012_187_361_745_992_642_956_581_746_628_302_955_570_299_024_324_153_181_617_210_465_832_036_786_906_117_260_158_783_520_751_516_284_225_540_265_170_483_304_226_143_974_286_933_061_690_897_968_482_590_125_458_327_168_226_458_066_526_769_958_652_682_272_807_075_781_391_858_178_889_652_208_164_348_344_825_993_266_043_367_660_176_999_612_831_860_788_386_150_279_465_955_131_156_552_036_093_988_180_612_138_558_600_301_435_694_527_224_206_344_631_797_460_594_682_573_103_790_084_024_432_438_465_657_245_014_402_821_885_252_470_935_190_620_929_023_136_493_273_497_565_513_958_720_559_654_228_749_774_011_413_346_962_715_422_845_862_377_387_538_230_483_865_688_976_461_927_383_814_900_140_767_310_446_640_259_899_490_222_221_765_904_339_901_886_018_566_526_485_061_799_702_356_193_897_017_860_040_811_889_729_918_311_021_171_229_845_901_641_921_068_884_387_121_855_646_124_960_798_722_908_519_296_819_372_388_642_614_839_657_382_291_123_125_024_186_649_353_143_970_137_428_531_926_649_875_337_218_940_694_281_434_118_520_158_014_123_344_828_015_051_399_694_290_153_483_077_644_569_099_073_152_433_278_288_269_864_602_789_864_321_139_083_506_217_095_002_597_389_863_554_277_196_742_822_248_757_586_765_752_344_220_207_573_630_569_498_825_087_968_928_162_753_848_863_396_909_959_826_280_956_121_450_994_871_701_244_516_461_260_379_029_309_120_889_086_942_028_510_640_182_154_399_457_156_805_941_872_748_998_094_254_742_173_582_401_063_677_404_595_741_785_160_829_230_135_358_081_840_096_996_372_524_230_560_855_903_700_624_271_243_416_909_004_153_690_105_933_983_835_777_939_410_970_027_753_472_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000
  end
end
```

이와 같이 재귀를 이용해 설계하고 코딩하는 패턴은 엘릭서(그리고 거의 모든 함수형 언어)에서 매우 일반적인 방법이다. 우선 정해진 답을 반환하는 가장 간단한 경우를 하나 찾는다. 이것이 일종의 기준점이 된다. 그리고 이 기준점에서 호출을 끄내는 재귀적인 답을 찾으면 된다. 예를 들어보자.

* 1부터 n까지의 자연수의 합
  * 0개 숫자의 합은 0이다.
  * n까지의 합은 n-1까지의 숫자의 합 + n이다.
* 리스트의 길이
  * 빈 리스트의 길이는 0이다.
  * 다른 리스트의 길이는 1 + 리스트 꼬리 부분의 길이다.

리스트의 '꼬리'는 리스트의 첫 번째 값을 제외한 나머지 리스트를 의미한다.

중요한 것은 이 정의들을 코드로 옮길 때 어떤 순서로 쓰는지에 따라 결과가 달라질 수 있다는 점이다. 엘릭서는 함수들에 대해 패턴 매칭을 수행할 때 코드의 위에서 아래 순서로 확인하며, 그중 처음으로 매칭되는 함수를 실행한다. 따라서 다음과 같은 코드는 제대로 동작하지 않는다.

```elixir
defmodule BadFactorial do
  def of(n), do: n * of(n - 1)
  def of(0), do: 1
end
```

어떤 값을 넣어 호출하든지 첫 번째 함수 정의에 매칭되므로 두 번째 함수 정의는 실행되지 않는다. 하지만 이런 경우에는 엘릭서 컴파일러가 도움을 준다. 이 코드를 컴파일하면 경고가 출력된다.

### 연습문제

1부터 n까지 정수의 합을 재귀적으로 구하는 sum(n) 함수를 구현하고 실행해보자.
새로운 파일에 모듈을 만들고 그 안에 함수를 구현한 뒤. IEx를 실행하고 파일을 컴파일해 실행하자.

```elixir
defmodule ExRun do
  def sum(0), do: 0
  def sum(n), do: n + sum(n - 1)
end
```

음이 아닌 두 정수의 최대공약수를 찾는 gcd(x, y) 함수를 구현해보자.
최대공약수 gcd(x, y)는 y가 0이면 x이고, 그렇지 않으면 gcd(y, rem(x, y))이다.

```elixir
# do
```

## 6.4 가드 조건절

지금까지 알아봤듯 엘릭서에서는 전달받은 인자를 이용한 패턴 매칭을 통해 어떤 함수를 실행할지를 결정한다. 그런데 인자의 타입이나 조건에 따라 실행될 함수를 결정하고 싶다면 어떻게 해야 할까? 이때 **가드 조건절(guard clause)**을 사용한다. 가드 조건절은 when 키워드를 사용해 함수 정의부에 붙일 수 있는 명제다. 패턴 매칭을 수행할 때 우선 파라미터를 이용한 전통적인 매칭을 수행하고, when이 붙어 있으면 조건을 검사한 뒤 참이어야만 함수를 실행한다.

```elixir
defmodule Guard do
  def what_is(x) when is_number(x) do
    IO.puts("#{x} is a number")
  end

  def what_is(x) when is_list(x) do
    IO.puts("#{inspect(x)} is a list")
  end

  def what_is(x) when is_atom(x) do
    IO.puts("#{x} is an atom")
  end
end

Guard.what_is(99)
Guard.what_is(:cat)
Guard.what_is([1, 2, 3])
```

앞에서 팩토리얼을 구현한 예제를 다시 한번 보자.

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule Factorial do
  def of(0), do: 1
  def of(n), do: n * of(n - 1)
end
```

인자로 음수를 넣으면 무한 루프에 빠진다. n의 값이 아무리 줄이더라도 0에는 도달하지 못하기 때문이다. 즉, 무한 루프에 들어가지 않도록 가드를 추가하는 편이 좋겠다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule Factorial do
  def of(0), do: 1

  def of(n) when is_integer(n) and n > 0 do
    n * of(n - 1)
  end
end
```

이렇게 구현된 함수에 음수 인자를 넣으면 어디에도 매칭되지 않을 것이다.
파라미터는 정수여야 하므로 타입에 대한 가드도 추가했다.

### 6.4.1 가드 조건절에 사용할 수 있는 것들

가드 조건절에는 엘릭서 표현식 중 일부만 사용할 수 있다. 다음 목록은 엘릭서 공식 가이드에 소개된 내용을 정리한 것이다.

#### 비교 연산자

`==` `!=` `===` `!==` `>` `<` `<=` `>=`

#### 이진 및 부정 연산자

`or` `and` `not` (!, ||, &&는 허용되지 않음에 유의)

#### 산술 연산자

`+` `-` `*` `/`

#### 연결 연산자

`<>` `++` (왼쪽이 리터럴일 때만 가능)

#### in 연산자

컬렉션 또는 범위 안에 값이 포함되는지를 확인한다.

#### 타입 확인 함수

다음 함수는 인자가 특정 타입일 때 true를 반환한다. 자세한 내용은 엘릭서 공식 문서에서 확인하자.

* `is_atom`
* `is_binary`
* `is_bitstring`
* `is_boolean`
* `is_exception`
* `is_float`
* `is_function`
* `is_integer`
* `is_list`
* `is_map`
* `is_map_key`
* `is_nil`
* `is_number`
* `is_pid`
* `is_port`
* `is_reference`
* `is_struct`
* `is_tuple`

#### 기타 함수들

다음 내장 함수는 true, false가 아닌 값을 반환한다.

* `abs(number)`
* `bianry_part(binary, start, length)`
* `bit_size(bitstring)`
* `byte_size(bitstring)`
* `ceil(number)`
* `div(number, number)`
* `elem(tuple, n)`
* `float(term)`
* `floor(number)`
* `hd(list)`
* `length(list)`
* `map_size(map)`
* `node()`
* `node(pid|ref|port)`
* `rem(number, number)`
* `tl(list)`
* `self()`
* `trunc(number)`
* `tuple_size(tuple)`

`ceil`, `floor` 함수는 엘릭서 1.8부터 사용할 수 있다. 이 목록에 있는 함수들은 Kernel 모듈에 정의되어 있어 별도 모듈 지정 없이 사용할 수 있다. 이 목록의 함수들을 조합하거나 얼랭 함수를 이용하는 함수들이 Bitwise, Integer, Record 모듈 등에 추가로 정의되어 있는데, 이 역시 가드 조건절에서 사용할 수 있다. 관련해서는 엘릭서 공식 문서를 참조하자.

## 6.5 기본 파라미터

기명 함수를 정의할 때 각 파라미터에 `param \\ value`문법을 사용해 기본값을 지정할 수 있다. 기본 파라미터가 있는 함수를 호출할 때, 엘릭서는 전달받은 인자 개수와 함수의 필수 파라미터 개숫(기본값이 정의되어 있지 ㅇ낳은 파라미터의 수)를 비교한다. 필수 파라미터 개수보다 적은 인자가 전달되면 함수에 매칭되지 않는다. 인자 개수와 필수 파라미터 개수가 같으면 인자들은 모두 필수 파라미터 자리에 들어가거, 나머지 파라미터들은 모두 기본값을 가진다. 인자가 필수 파라미터 개수보다 많으면 넘치는 수만큼 기본값을 왼쪽부터 덮어쓴다.

```elixir
defmodule Example do
  def func(p1, p2 \\ 2, p3 \\ 3, p4) do
    IO.inspect([p1, p2, p3, p4])
  end
end

Example.func("a", "b")
Example.func("a", "b", "c")
Example.func("a", "b", "c", "d")
```

기본 파라미터를 정의한 함수는 패턴 매칭 시 신기한 동작을 보인다. 예를 들어보자.

<!-- livebook:{"continue_on_error":true} -->

```elixir
def func(p1, p2 \\ 2, p3 \\ 3, p4) do
  IO.inspect([p1, p2, p3, p4])
end

def func(p1, p2) do
  IO.inspect([p1, p2])
end
```

코드를 컴파일하면 다음과 같은 오류가 출력된다.

```log
** (CompileError) default_params.exs:7: def func/2 conflicts with defaults from def func/4
```

오류가 출력되는 이유는 첫 번째 함수 정의(기본 파라미터가 있는 함수)가 인자 2개, 3개, 4개인 함수 호출에 모두 매칭되기 때문이다. 기억해야 할 특징이 하나 더 있다. 기본 파라미터를 가지는 함수에 여러 구현을 정의한 경우다.

```elixir
defmodule DefaultParams1 do
  def func(p1, p2 \\ 123) do
    IO.inspect([p1, p2])
  end

  def func(p1, 99) do
    IO.puts("you said 99")
  end
end
```

코드를 컴파일하면 경고가 발생한다.

```log
warning: variable "p1" is unused (if the variable is not meant to be used, prefix it with an underscore)
  default_params1.exs:6: DefaultParams1.func/2

warning: def func/2 has multiple clauses and also declares default values. In such cases, the default values should be defined in a header. Instead of:

    def foo(:first_clause, b \\ :default) do ... end
    def foo(:second_clause, b) do ... end

one should write:

    def foo(a, b \\ :default)
    def foo(:first_clause, b) do ... end
    def foo(:second_clause, b) do ... end

  default_params1.exs:6

warning: this clause for func/2 cannot match because a previous clause at line 2 always matches
  default_params1.exs:6
```

이는 기본값으로 인해 발생하는 혼동을 줄이기 위한 의도적인 동작이다. 이때 기본 파라미터를 사용하려면 우선 기본값 파라미터가 있는 함수를 본문 없이 정의하고, 나머지 함수들은 기본값 없이 정의하면 된다. 이렇게 하면 처음에 정의한 기본값이 모든 함수 호출에 적용된다.

### 연습문제

1과 1,000 사이의 임의의 숫자를 맞혀보자. 숫자를 맞히는 가장 효율적인 방법은
최댓값과 최솟값의 중간값으로 추정해보는 것이다.
추정한 값이 더 크다면 정답은 최솟값과 추정한 값 사이에 있다.
반대로 추정한 값이 더 작다면 정답은 추정한 ㄱ밧과 최댓갓ㅂ 사이에 있다.
구현할 함수는 guess(actual, range)이다. actual은 맞힐 값, range는 최솟값과 최댓값을 나타내는 엘릭서 범위 타입의 값이다.
출력은 다음 예와 비슷해야 한다.

```sh
iex > Chop.guess(273, 1..1000)
Is It 500
Is It 250
Is It 375
Is It 312
Is It 281
Is It 273
273
```

* 힌트
  * 현재 추정한 값을 추가 파라미터로 갖는 헬퍼 함수를 구현해야 한다.
  * div(a, b) 함수로 정수 나눗셈을 할 수 있다.
  * 가드 조건절을 활용하자.
  * 패턴 매칭으로 범위 타입의 시작과 끝 값을 매칭할 수 있다.(예: a..b = 4..8 )

```elixir
defmodule Chop do
  def guess(actual, range) do
    guess(actual, range, div(range.first + range.last, 2))
  end

  def guess(actual, range, guess) when guess > actual do
    IO.puts("Is It #{guess}")
    guess(actual, range.first..guess, div(range.first + guess, 2))
  end

  def guess(actual, range, guess) when guess < actual do
    IO.puts("Is It #{guess}")
    guess(actual, guess..range.last, div(guess + range.last, 2))
  end

  # 위 함수를 만들긴했는데 함수의 이름과 인자의 이름이 똑같을때 elixir는 함수인지 인자인지 어떻게 구분할수있지?
  def guess(actual, _range, guess) when guess == actual do
    IO.puts("Is It #{guess}")
    IO.puts(guess)
  end
end

Chop.guess(273, 1..1000)
```

## 6.6 프라이빗 함수

`defp` 매크로로 프라이빗 함수를 정의 할 수있다. 어디서든 호출할 수 있는 퍼블릭 함수와 달리, 프라이빗 함수는 정의된 모듈 내에서만 호출할 수 있다. 프라이빗 함수 역시 `def`로 퍼블릭 함수를 정의할 때와 마찬가지로 한 함수를 여러 번 정의할 수 없다. 하지만 하나의 함수를 일부는 퍼블릭으로, 일부는 프라이빗으로 정의할 수는 없다. 즉 다음은 잘못된 코드다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
def fun(a) when is_list(a), do: true
defp fun(a), do: false
```

## 6.7 끝내주는 파이프 연산자 `|>`

마지막까지 아껴둔, 함수에서 가장 맛있는 부분을 소개한다. 지금까지 이런 식의 코드를 많이 봐왔을 것이다.

```
people = DB.find_customers
orders = Orders.for_customers(people)
tax    = sales_tax(orders, 2018)
filing = prepare_filing(tax)
```

먹고 살기 위해 하는 프로그래밍이다. 이건 그나마 나은데, 다른 방식으로 쓰면 다음처럼 된다.

```
filing = prepare_filing(sales_tax(Orders.for_customers(DB.find_customers), 2018))
```

어린아이들에게 채소를 먹일 떄나 쓸 만한 코드다. 읽기도 힘들뿐더러 연산이 이루어지는 순서를 이해하려면 함수의 안쪽부터 거슬러 나와야 한다. 엘릭서에서는 더 나은 방법을 사용한다.

```exs
filing = DB.find_customers
  |> Orders.for_customers
  |> sales_tax(2018)
  |> prepare_filing
```

`|>` 연산자는 왼쪽 표현식의 결과를 받아서 오른쪽에 있는 함수의 첫 번쨰 파라미터에 넣는다. 이함수가 만환하는 주문 리스트는 `sales_tax`의 첫 번째 인자가 되며, 2018은 두 번째 인자가 된다. 기본적으로 `val |> f(a, b)`는 `f(val, a, b)`와 같다.

```exs
list
|> sales_tax(2018)
|> prepare_filing
```

이 코드는 `prepare_filing(sales_tax(list, 2018))`과 같다.

앞서 본 예제에서 식을 이루는 가가 부분을 줄을 나누어 썻는데, 다음처럼 한 줄에 이어 쓸 수도있다. 두 방법 모두 엘릭서에서 유효한 문법이다.

```sh
iex > (1..10) |> Enum.map(&(&1*&1)) |> Enum.filter(&(&1 < 40))
[1, 4, 9, 16, 25, 36]
```

함수의 인자를 전달할 때 괄호를 써야 함에 유의하자. 그렇지 않으면 함수를 축약할 떄 쓰는 `&`와 파이프 연산자가 충돌한다.

```
WARING_ 다시 한번 강조한다. 파이프라인 안에 있는 함수 호출에서는 파라미터에 항상 괄호를 씌워야 한다.
```

파이프 연산자가 좋은 점은 코드를 명세와 닮은 꼴로 쓸 수 있다는 점이다. 앞서 살펴본 매출-세금 예제에서는 명세서에 이런 식으로 쓰여 있을 것이다.

* 고객 명단을 구한다.
* 고객들이 구문한 내역을 구한다.
* 주문 내역에 대한 세금을 계산한다.
* 세금을 신고한다.

이 명세를 코드로 바꾸려면 항목 사이이에 `|>`를 넣고 각각을 함수로 구현하기만 하면 된다.

```exs
DB.find_customers
|> Orders.for_customers
|> sales_tax(2018)
|> prepare_filing
```

프로그래밍은 데이터를 변형하는 작업이며 `|>` 연산자는 변형을 명시적으로 하게 해준다. 이제 이 책의 원서에서 언어를 한 마디로 소개하는 `Function |> Concurrent |> Pragmatic |> Fun`의 의미를 이해할 수 있을 것이다.

## 6.8 모듈

모듈은 당신이 정의한 것들에 네임스페이스를 만들어준다. 6.1절에서 기명함수를 한데 묶을 떄 사용한 적이 있다. 모듈은 함수만이 아니라 매크로, 구조체, 프로토콜, 심지어는 다른 모듈까지도 포함할 수 있다.

모듈 안에 정의된 함수를 모듈 밖에서 참조하려면 함수명 앞에 모듈 이름을 붙여야 한다. 같은 모듈 안에 있는 함수를 호출할 떄는 붙이지 않아도 된다. 예를 들면 다음과 같다.

```exs
defmodule Mod do
  def func1 do
    IO.puts "in func1"
  end
  def func2 do
    func1
    IO.puts "in func2"
  end
end

Mod.func1
Mod.func2
```

func1과 func2는 같은 모듈 안에 있으므로 func2에서는 func1을 모듈명을 지정하지 않고 바로 호출한다. 모듈 밖에서는 `Mod.func1`과 같이 모듈명까지 지정해야 한다. 다른 프로그래밍 언어에서와 마찬가지로 엘릭서에서도 코드의 가독성과 재사용성을 높이기 위해 모듈을 중첩해 정의할 수 있다. 그런 면에서 모든 개발자는 라이브러리를 만들고 있는지도 모른다.

중첩된 모듈 안의 함수에 외부에서 접근하려면 모듈 이름을 모두 적어주어야 한다. 어떤 모듈에서 내부 모듈에 접근할 떄는 모듈 이름을 모두 적어도 되고, 내부 모듈의 이름만 적어도 괜찮다.

```exs
defmoulde Outer do
  defmodule Inner do
    def inner_func do
    end
  end

  def outer_func do
    Inner.inner_func
  end
end

Outer.outer_func
Outer.Inner.inner_func
```

사실 엘릭서에서의 모듈 중첩은 일종의 허상이다. 모든 모듈은 최상위에 정의된다. 코드상으로 모듈을 중첩해서 정의하더라도 엘릭서는 외부 모듈명을 내부 모듈명 앞에 온점(.)으로 연결해 모듈명으로 삼는다. 즉, 중첩된 모듈을 직접 정의할 수도 있다는 뜻이다.

```exs
defmodule Mix.Task.Doctest do
  def run do
  end
end

Mix.Tasks.Doctest.run
```

이는 모듈 `Mix`와 `Mix.Tasks.Doctest` 사이에 특별한 관계가 없음을 의미하기도 한다.

### 6.8.1 모듈 지시자

엘릭서에서는 다른 모듈을 사용할 때 세 가지 지시자를 사용한다. 셋 모두 프로그램이 시작하면 함께 실행되며 **문법적 스코프**를 가진다. 지시자의 효과는 지시자를 만난 곳부터 코드를 감싸는 블록이 끝날 때 까지 유효하다. 즉 지시자가 모듈 내에 정의했다면 해당 모듈 정의가 끝날 때까지 사용할 수 있으며, 함수 내에 정의했다면 해당 함수 정의가 끝날 떄까지 유효하다.

#### import 지시자

import는 다른 모듈의 함수와 매크로를 현재 스코프로 가져온다. 코드에서 특정 모듈을 자주 사용할 때 import를 사용해서 가져오면 모듈명을 반복하는 수고를 덜 수 있다. 예를 들어 List 모듈의 faltten 함수를 임포트하면 모듈명을 지정하지 않고도 faltten 함수를 호출할 수 있다.

```exs
defmodule Example do
  def func1 do
    List.faltten [1, [2,3], 4]
  end
  def func2 do
    import List, only: [flatten: 1]
    flatten [5, [6,7], 8]
  end
end
```

import의 전체 문법은 다음과 같다

```exs
import Module [, only:|except: ]
```

두 번쨰 파라미터는 필수는 아니지만, 특정 함수나 매크로만을 가져오거나 제외하는 데 사용한다. `only:`나 `except:`뒤에 **함수명: 인자 수** 쌍의 리스트를 넣어주면 된다. 가능한 작은 스코프에서 import를 사용하고, `only:`를 이용해 필요한 함수만 임포트하기를 권장한다.

```exs
import List, only: [flatten: 1, duplicate: 2]
```

`only:`에 `:functions`나 `:macros` 아톰을 지정해 함수만, 혹은 매크로만 임포트할 수도 있다.

#### alias 지시자

alias 지시자는 모듈에 별칭을 생성한다. 주목적은 타이핑할 수고를 줄이는 것이다.

```exs
defmodule Example do
  def compile_end_go(source) do
    alias My.Other.Module.Parser, as: Parser
    alias My.Other.Module.Runner, as: Runner
    source
    |> Parser.parse()
    |> Runner.execute()
  end
end
```

`as:` 파라미터는 기본적으로 모듈명의 마지막 부분으로 지정되므로 앞의 alias는 다음과 같이 줄여 쓸 수 있다.

```exs
alias My.Other.Module.Parser
alias My.Ohter.Module.Runner
```

더 줄여 쓸 수도 있다.

```exs
alias My.Other.Module.{Parser, Runner}
```

#### require 지시자

require는 다른 모듈에 정의된 매크로를 호출하고자 할 때 사용한다. 코드가 컴파일될 때 다른 모듈의 매크로를 이용할 수 있음을 보장해준다.

## 6.9 모듈 속성

엘릭서의 각 모듈은 메타데이터를 가질 수 있다. 메타데이터를 이루는 각 항목을 **모듈 속성**이라 부르며, 각각은 이름을 가진다. 모듈 내에서는 속성 이름 앞에 `@`를 붙여서 해당 값에 접근한다. 속성에 값을 설정하려면 다음처럼 한다. `@name value`

이 구문은 모듈의 최상위에서만 사용할 수 있다. 다시 말해, 함수 정의 내에서는 모듈 속성에 값을 설정할 수 없고, 값을 읽는 것만 가능하다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule Example69 do
  @author "Dave Thomas"
  def get_author do
    @author
  end
end

IO.puts("Example was written by #{Example69.get_author()}")
```

모듈 안에서 같은 속성의 값을 여러 번 설정할 수도 있다. 함수에서 모듈 속성에 접근하는 경우 속성의 값은 함수가 정의될 당시의 값으로 설정된다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
defmodule Example69_2 do
  @attr "one"
  def first, do: @attr
  @attr "two"
  def second, do: @attr
end

# => two one
IO.puts("#{Example69_2.second()} #{Example69_2.first()}")
```

모듈 속성은 일반 변수와는 다르다. 많은 개바라가 자바나 루비의 상수처럼 사용하지만 가급적 설정과 메타데이터 용도로만 사용하기를 권장한다.

## 6.10 모듈의 이름: 엘릭서, 얼랭, 아톰

엘릭서 모듈은 대체로 String이나 PhotoAlbum과 같은 이름을 가진다. 그리고 모듈 안에 정의된 함수는 String.length("abc")와 같은 식으로 호출한다. 사실 이 과정에서는 내부적으로 미묘한 일이 일어난다. 모듈 이름은 사실 하나의 아톰이다. 대문자로 시작하는 모듈 이름을 하나 쓰면 엘릭서는 이를 Elixir가 붙은 아톰으로 바꾼다. 예를 들어 IO 모듈은 Elixir.IO가 되며, Dog 모듈은 Elixir.Dog가 된다.

```sh
iex> is_atom IO
true
iex> to_string IO
"Elixir.IO"
iex> :"Elixir.IO" === IO
true
```

즉 모듈 안에 있는 함수를 호출하는 코드는 실제로는 아톰 뒤에 점을 하나 찍고 함수명을 이어붙인 형태다. 따라서 함수를 다음처럼 호출할 수도 있다.

```sh
iex> IO.puts 123
123
:ok
iex> :"Elixir.IO".puts 123
123
:ok
```

심지어는 다음처럼 할 수도 있다.

```sh
iex> my_io = IO
IO
iex> my_io.puts 123
123
:ok
```

## 6.11 얼랭 아리브러리의 함수 호출하기

얼랭에서 변수나 모듈의 이름을 정하는 컨벤션은 엘릭서와 사뭇 다르다. 얼랭에서 변수 이름은 대문자로 시작하며 아톰은 소문자로 시작한다. 예를 들어 얼랭의 timer 모듈을 얼래에서는 imter라는 아톰 그대로 사용할 수 있지만, 엘릭서에서는 :timer라고 써야 한다. timer 모듈내의 tc라는 함수를 엘릭서에서 사용하려면 `:timer.tc`와 같이 써야 한다(맨 앞에 콜론이 필요하다.)

실수를 총 세 글자, 소수점 아래 한 자리까지 허용하는 필드에 출력한다고 해보자. 얼랭에는 이를 지원하는 함수가 있다. erlang format으로 검색해보면 얼랭 io 모듈의 format이라는 함수를 찾을 수 있다.

문서에 따르면 얼랭에서는 이 함수를 io.format과 같이 호출하므로, 엘릭서에서는 얼래의 모듈명을 엘릭서 아톰으로 바꾸어 호출하면 된다.

```sh
iex> :io.format("The number is ~3.1f~n" [5.678])
The number is .57
:ok
```

## 6.12 라이브러리 찾기

애플리케이션에서 사용할 라이브러리가 필요하다면 우선 엘릭서 모듈 중에서 찾아보면 좋다. 기본 내장된 모듈에 대한 설명은 엘릭서 공식 웹사이트에 있으며, 나머지 모듈은 `https://hex.pm`이나 깃허브에 공개되어 있다.

만약 찾기 못했다면 얼랭 내장 라이브러리를 찾아보거나 인터넷 검색을 해보자. 얼랭 라이브러리 역시 당신의 프로젝트에서 사용할 수있다. 단 얼랭 라이브러리 문서는 얼랭 컨벤션을 사용한다는 점에 주의하자. 얼래에서 변수는 대문자로 시작하며, 소문자로 시작하는 식별자는 아톰이다(즉, 얼랭에서 tomato로 쓰면 엘릭서에서는 `:tomato`로 써야한다).

함수에 대해 살펴봤으니, 이제부터는 초점을 함수가 다루는 데이터로 옮겨보자.

### 연습문제

다음 기능을 하는 라이브러리 함수들을 각각 찾아 IEx에서 실행해보자. 문제 뒤에 [엘릭서]가 붙었으면 엘릭서 라이브러리에서, [얼랭]이 붙어있으면 얼랭라이브러리에서 찾으면 된다.

* 소수를 소수점 아래 두 자리까지 문자열로 바꾸는 함수 [얼랭]
* 운영체제의 환경 변수를 얻어오는 함수 [엘릭서]
* 파일의 확장자를 반환하는 함수(예를 들어 "dave/test.exe"가 주어지면 .exs를 반환) [엘릭서]
* 현재 작업 디렉터리를 반환하는 함수 [엘릭서]
* JSON 형식의 문자열을 엘릭서 자료구조로 바꾸는 함수(설치하지는 말고 검색만 해보자)
* 운영체제의 셀에서 명령어를 실행하는 함수

## 7. 리스트와 재귀

이 장에서 살펴볼 내용은 다음과 같다.

* 리스트의 재귀적 구조
* 리스트 탐색하기, 리스트 만들기
* 맵, 리듀스 연산 구현하기

전통적인 언어에서 리스트를 이용해 프로그램을 작성할 떄는 일반적으로 리스트를 순회 대상으로 여겼으며 반복문으로 다루는 것이 자연스러웠다. 하지만 정말 그렇다면 '리스트와 재귀'라는 장은 필요하지 않을 것이다. 문제를 올바른 방식으로 바라본다면 재귀야말로 링크드 리스트를 다루는 완벽한 도구다.

## 7.1 리스트의 머리와 꼬리

리스트는 비어있거나 머리와 꼬리로 구성되어 있다. 머리는 값을 담고, 꼬리는 머리를 제외한 나머지 값을 담은 리스트다. 이는 리스트의 재귀적 정의다. 빈 리스트는 다음과 같이 쓴다.

```
[]
```

파이프 기호 ( | )를 사용해서 리스트의 머리와 꼬리 사이를 구분할 수 있다고 상상해보자. 우리가 흔이 `[ 3 ]`과 같이 쓰는 값 하나짜리 리스트는, 3이라는 값이 빈 리스트와 이어져 있는 것처럼 바꾸오 쓸 수 있다

```
[ 3 | [] ]
```

파리프 기호 왼쪽에 있는 값을 리스트의 머리라고 하고, 오른쪽 리스트의 꼬리라고 하자. 리스트 `[2, 3 ]`에서 머리는 2고 꼬리는 ㄱ밧 하나짜리 리스트`[3]`다. 그런데 꼬리에 해당하는 리스트는 바로 앞 예제에서 봤다. `[2, 3]`은 다음 처럼 쓸 수도 있다.

```
[ 2 | [ 3 | [] ]]
```

리스트에 값을 하나 추가해 `[1, 2, 3]`을 만들자. 이 리스트는 머리가 1이고 그 뒤에 `[2, 3]`이 이어지는데, 뒤에 이어지는 리스트는 바로 앞에서도 봤다.

```
[ 1 | [ 2 | [3 | [] ]]]
```

놀랍게도 이 표기는 유효한 엘릭서 문법이다. IEx에 그대로 입력해 보자.

```sh
iex> [ 1 | 2 | [ 3 | [] ]]
[1, 2, 3]
```

그리고 여기서 마법이 시작된다. 패턴매칭을 다루면서, 패턴에 리스트도 사용할 수 있으며 이때 우변에 있는 리스트의 값이 좌변으로 할당됨을 살펴봤다.

```sh
iex> [a, b, c] = [1, 2, 3]
[1, 2, 3]
iex> a
1
iex> b
b
iex> c
3
```

한발 더 나아가 파이프 기호를 패턴에 사용할 수도 있다. 파이프 기호 왼쪽에는 리스트의 머리 부분이 매칭되고, 오른쪽에는 꼬리 부분이 매칭된다.

```sh
iex> [ head | tail ] = [1, 2, 3]
[1, 2, 3]
iex> head
1
iex> tail
[2, 3]
```

## 7.3 머리와 꼬리를 사용해 리스트 만들기

이제 조금 더 과감해지자, 숫자로 이루어진 리스트를 받아, 그 숫자들의 제곱을 새로운 리스로 반환하는 함수를 만들어보자.

```elixir
defmodule Test do
  def square([]), do: []
  def square([head | tail]), do: [head * head | square(tail)]
end

IO.inspect(Test.square([1, 2, 3, 4, 5]))
```

코드는 짧지만 많은 의미를 담고 있다. 먼저 각 square 함수의 파라미터 패턴에 주목하자. 첫 번째 정의는 빈 리스트에 매칭되고, 두 번째 정의는 나머지 리스트에 매칭된다. 이어서 두 번째 함수 정의의 본문을 보자.

```exs
def square([ head | tail ]), do: [ head * head | square(tail) ]
```

비어 있지 않은 리스트가 패턴 매칭되면 새로운 리스트가 반환된다. 새로운 리스트의 머리는 원래 리스트 머리의 값의 제곱이고, 꼬리는 원래 리스트의 꼬리를 square 함수에 넣어 반환받은 리스트가 된다. 재귀적으로 리스트를 연산하고 있다.

## 7.4 맵 함수 만들기

`square`와 `add_1` 모두 실제 연산은 함수의 두 번째 정의에서 이루어졌다. 그리고 그 정의도 거의 비슷한 내용이었다. 둘 다 새로운 리스트를 반환했는데, 새로운 리스트의 머리 부분은 인자의 머리의 값을 제곱하거나 1을 더한 결과였고, 꼬리 부분은 인자의 꼬리를 새로운 인자로 한 재귀 호출의 결과였다. 이 동작을 일반화해 map이라는 함수를 새로 정의해보자. 이 함수는 리스트와 함수를 받아 새로운 리스트를 반환하는데, 반환되는 리스에는 인자로 받은 함수를 원본 리스트의 각 요소에 적용한 결과를 담는다.

```exs
def map([], _func), do: []
def map([ head | tail ], func), do: [ func.(head) | map(tail, func) ]
```

map 함수는 square, add_1 함수와 거의 동일하다. 빈 리스트를 받으면 빈 리스트를 반환한다. 그렇지 않으면 새로운 리스트를 반환하는데, 리스트의 머리는 인자로 받은 함수를 적용한 값이고, 꼬리는 같은 함수를 재귀 호출한 결과다. 빈 리스트에 대한 함수 구현에서는 인자로 받은 함수를 사용하지 않으므로 두 번째 파라미터의 이름에 `_func`와 같이 언더스코어를 붙였다. 언더스코어를 사용하면 변수가 사용되지 않았을 때 발생하는 경고를 제거해준다. 리스트와 함수(fn으로 정의할 수 있다)를 전달해 함수를 호출해보자.

```sh
iex> c "mylist1.exs"
[MyList]
iex> MyList.map [1,2,3,4], fn (n) -> n*n end
[1, 4, 9, 16]
```

함수 역시 기본 내장 자료형으로, fn과 end 사이에 본문을 넣어 정의한다. 이렇게 정의한 함수는 map 함수의 두 번째 인자(func)가 되고, map 함수 안에서 `func.(head)`와 같이 호출된다. 그러면 head의 값이 제곱이 되어 새 리스트에 들어간다. map에 다른 함수를 넣어 호출해보자.

```sh
iex> MyList.map [1,2,3,4], fn (n) -> n+1 end
[2, 3, 4, 5]
```

& 표기법으로도 같은 동작을 구현할 수 있다.

```sh
iex> MyList.map [1,2,3,4], &(&1 + 1)
```

## 7.5 리스트를 줄여 하나의 값으로 만들기

방금 만든 `map/2` 함수는 리스트의 각 요소에 독립적으로 함수를 적용하는 개념을 추상화한 것이다. 그렇다면 함수를 요소마다 적용하는 것이 아니라 여러 요소에 걸쳐 적용하고 싶을 때는 어떻게 할까? 리스트의 있는 값을 모두 더하거나. 곱하거나 또는 리스트에서 가장 큰 값을 찾아내는 작업은 어떻게 추상화할까?

컬렉션의 모든 값을 더하는 sum 함수는 컬렉션을 줄여(reduce) 하나의 값으로 만든다. 걸렉션에서 가장 크거나 작은 값을 찾거나, 각 요소를 곱하거나, 모든 문자열을 합치는 함수도 마찬가지다. 그렇다면 컬렉션을 하나의 값으로 줄이는 일반화된 함수는 어떻게 만들까?

일단 컬렉션을 받아야 한다. 초기값도 필요하다(sum/1 함수는 0을 초기값으로 받게 된다). 또 한 함수도 하나 있어야 하는데, 이 함수는 현재까지의 누적된 연산 결과(컬렉션의 앞부분을 하나의 값으로 줄인 결과)와 컬렉션의 다음 값을 받아 연산의 다음 결과를 반환한다. 따라서 우리가 만들 reduce 함수는 다음처럼 인자 세 개를 받는다.

```exs
reduce(collection, initial_value, func)
```

이제 이 함수를 재귀적으로 설계해보자.

* `reduce([ ], value, _value) -> value`

* `reduce([ head | tail ], value, func) -> reduce(tail, fun(head, value) ,fun)`

reduce 함수는 리스트의 머리와 연산의 현재 값에 함수를 적용한다. 그리고 리스트의 꼬리에 reduce 연산을 적용할 때 그 연산 결과를 새로운 현재 값으로 전달한다. 다음 코드는 reduce 함수의 구현이다. 앞서 본 재귀적 설계를 잘 따르는지 확인하자.

```elixir
defmodule MyList do
  def reduce([], value, _) do
    value
  end

  def reduce([head | tail], value, func) do
    reduce(tail, func.(head, value), func)
  end
end
```

당연하지만 함수를 전달할 때 & 표기법도 사용할 수 있다.

```exs
iex> c "reduce.exs"
[MyList]
iex> MyList.reduce([1,2,3,4,5], 0, &(&1 + &2))
15
iex> MyList.reduce([1,2,3,4,5], 1, &(&1 * &2))
120
```

### 연습문제

리스트와 함수를 받는 mapsum 함수를 만들어보자.
이 함수는 리스트의 각 요소에 함수를 적용한 뒤, 그 결과를 모두 더한 값을 반환한다.

```
iex> MyList.mapsum([1,2,3,4], &(&1 * &1)) # 14
```

```elixir
defmodule MyList75_ex1 do
  def len([]), do: 0
  def len([_ | tail]), do: 1 + len(tail)

  def map([], _func), do: []
  def map([head | tail], func), do: [func.(head) | map(tail, func)]

  def reduce([], value, _) do
    value
  end

  def reduce([head | tail], value, func) do
    reduce(tail, func.(head, value), func)
  end

  # RUN
  def mapsum(list, func) do
    list
    |> MyList75_ex1.map(func)
    |> MyList75_ex1.reduce(0, &(&1 + &2))
  end
end
```

이번에는 max(list) 함수를 구현해보자. 이 함수는 리스트에서 가장 큰 값을 반환한다(생각보다 조금 어려울 수 있다)

```elixir
defmodule MyList75_ex2 do
  def len([]), do: 0
  def len([_ | tail]), do: 1 + len(tail)

  def map([], _func), do: []
  def map([head | tail], func), do: [func.(head) | map(tail, func)]

  def reduce([], value, _) do
    value
  end

  def reduce([head | tail], value, func) do
    reduce(tail, func.(head, value), func)
  end

  # RUN
  def max([]), do: 0

  def max(list) do
    list
    |> reduce(
      0,
      fn n, n2 -> if n > n2, do: n, else: n2 end
    )
  end
end
```

TODO: 문제풀기
엘릭서에서 작은따옴표로 둘러싸인 문자열은사실 각 문자 코드들의 리스트다.
리스트의 각 요소에 n을 더하는 caesar(list, n) 함수를 만들어보자.
만약 더한 문자 코드의 값이 'z'를 넘어가면 'a'로 돌아가 이어서 세어주자.

```
iex> MyList.caesar('ryvkve', 13)
????? (직접 맞혀보자!)
```

## 7.6 더 복잡한 리스트 패턴

값을 하나씩 처리하는 방법으로 모든 리스트 문제를 풀 수 있는 것은 아니다. 다행이 조인 연산자 `|`는 연산자 왼쪽에 여러 값을 두도록 해준다. 따라서 다음과 같이 쓸 수도 있다.

```elixir
[1, 2, 3 | [4, 5, 6]]
# [1, 2, 3, 4, 5, 6]
```

패턴 매칭에서도 똑같이 동작한다. 따라서 리스트의 앞부분에 있는 여러 값을 한꺼번에 매칭할 수 있다. 예를 들어 다음 프로그램은 리스트의 값을 한 쌍씩 묶어 순서를 바꾼다.

```elixir
defmodule Swapper do
  def swap([]), do: []
  def swap([a, b | tail]), do: [b, a | swap(tail)]
  def swap([_]), do: raise("Can't swap a list with an odd number of elements")
end
```

위 코드를 실행해보면

```log
** (RuntimeError) Can't swap a list with an odd number of elements
    swap.exs:4: Swapper.swap/1
    swap.exs:3: Swapper.swap/1
    swap.exs:8: (file)
```

swap 함수의 세 번째 정의에는 값 하나짜리 리스트가 매칭된다. 재귀 호출을 수행한 결과 리스트에 값이 하나만 남았을 때가 이 경우에 해당한다. 매 호출마다 값을 두 개씩 처리하고 있으므로, 처음에 받은 리스트의 길이가 홀수일 때 이 패턴이 매칭된다.

### 7.6.1 리스트의 리스트

이번에는 여러 날씨 관측소에서 온도와 강수량을 기록한다고 해보자. 각 기록은 다음 형태로 저장된다.

```
[ timestamp, location_id, temperature, rainfall ]
```

기록들의 리스트를 받아, 27번 관측소에서 보내온 기록들만 찾아보자.

```exs
defmodule WeatherHistory do
  def for_location_27([]), do: []
  def for_location_27([ time, 27, temp, rain ] | tail) do
    [ [time, 27, temp, rain] | for_location_27(tail)]
  end
  def for_location_27([ _ | tail]), do: for_location_27(tail)
end
```

이 코드는 리스트가 빌 때까지 재귀처리하는 경우의 일반적인 구현이다. 그런데 함수의 두 번째 정의를 보자. 지금까지는 리스트의 첫 번째 값을 head라는 변수에 매칭했는데, 여기에 다음과 같은 패턴이 자리하고 있다.

```exs
for_location_27([ [time, 27, temp, rain] | tail])
```

패턴에 매칭되려면 리스트의 첫 번째 값 네 개짜리 리스트여야 하고, 내부 리스트의 두번째 값이 27이어야 한다. 이 함수는 우리가 원하는 날씨 관측소의 기록에만 실행된다. 한편 이러한 방식으로 필터링을 수행할 때는 조건에 매칭되지 않는 경우도 생각해야 한다. 함수의 세 번째 정의가 바로 그 역활을 해준다. 세 번째 파라미터 목록을 다음처럼 작성할 수도 있다.

```exs
for_location_27([ [time, _, temp, rain ] | tail])
```

하지만 실제로는 리스트의 첫 번째 값이 무엇이든, 어떤 형식이든 상관없이 매칭되어야 한다. 같은 모듈에 간단한 테스트 데이터를 정의해두었다.

```elixir
def test_data do
  [
    [1_366_225_622, 26, 15, 0.125],
    [1_366_225_622, 27, 15, 0.45],
    [1_366_225_622, 28, 21, 0.25],
    [1_366_229_222, 26, 19, 0.081],
    [1_366_229_222, 27, 17, 0.468],
    [1_366_229_222, 28, 15, 0.601],
    [1_366_232_822, 26, 22, 0.095],
    [1_366_232_822, 27, 21, 0.051],
    [1_366_232_822, 28, 24, 0.03],
    [1_366_236_422, 26, 17, 0.025]
  ]
end
```

이 데이터로 IEx에서 함수를 실행해보자. 더 쉽게 실행하기 위해 `import` 함수를 사용한다. `import`를 사용하면 WeatherHistory 모듈에 있는 함수들을 로컬 네임 스코프로 가져올 수 있다. 따라서 `import`를 호출한 다음에는 함수 호출 시 모듈명을 앞에 적지 않아도 된다.

```sh
iex> c "weahter.exs"
[WeatherHistory]
iex> import WeatherHistory
WeatherHistory
iex> for_location_27(test_data)
[
  [1366225622, 27, 15, 0.45],
  [1366229222, 27, 17, 0.468],
  [1366232822, 27, 21, 0.051]
]
```

이 함수는 특정 관측소의 데이터만 가져올 수 있다는 한계가 있다. 원하는 관측소의 위치를 파라미터로 전달할 수 있다면 더 좋을 것이다. 이때도 패턴 매칭을 사용한다.

### 연습문제

TODO:

`MyList.span(from, to)` 함수를 만들어보자. 이 함수는 from부터 to까지의 숫자를 리스트로 반환한다.

## 7.7 리스트 모듈 실전

List 모듈은 리스트를 다루기 위한 여러 함수를 제공한다.

```elixir
[1, 2, 3] ++ [4, 5, 6]
```

## 8. 맵, 키워드 리스트, 집합, 구조체

맵, 키워드 리스트, 집합, 구조체

이 장에서 살펴볼 내용은 다음과 같다.

* 딕셔너리 방식 자료형 두어 개
* 구조체
* 중첩된 자료구조

딕셔너리는 키와 값을 연결해 데이터를 저장하는 자료형을 말한다. 딕셔너리에 해당하는 맵과 키워드 리스트는 4장에서 간략하게 살펴봤다. 이번 장에서는 패턴 매칭에서 딕셔너리 타입을 사용하는 방법과 데이터를 수정하는 방법을 다운다. 이어서 정해진 구조를 가진 특수한 맵인 구조체를 알아보고, 마지막으로 중첩된 자료구조(이를테면 맵 안에 있는 맵)에서 필드를 수정하는 방법을 찾아본다.

## 8.8 집합
