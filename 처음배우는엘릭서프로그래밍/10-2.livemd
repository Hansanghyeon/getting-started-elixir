# 처음배우는엘릭서프로그래밍

## 10.2 Stream: 지연 계산하기

엘릭서에서 `Enum` 모듈은 소위 '탐욕스러운' 연산을 한다. 즉, 컬렉션을 전달하면 그 컬렉셔느이 모든 값들에 연산을 수행한다. 그리고 수행한 결과는 일반적으로 새로운 컬렉션이 된다. 다음 파이프라인 예제를 보자.

```elixir
[1, 2, 3, 4, 5]
|> Enum.map(&(&1 * &1))
# [1, 4, 9, 16, 25]
|> Enum.with_index()
# [{1, 0}, {4, 1}, {9, 2}, {16, 3}, {25, 4}]
|> Enum.map(fn {value, index} -> value - index end)
# [1, 3, 7, 13, 21]
|> IO.inspect()
```

처음 나오는 map 함수는 원본 리스트를 받아 각 값을 제곱한 새로운 리스트를 만든다. `with_index`는 이 리스트를 받아 `{값, 인덱스}` 튜플 리스트를 반환하며, 이어지는 map 함수는 각 항목의 값에서 인덱스를 빼어 `IO.inspect`에 전달한다. 즉 이 파이프라인은 최종 결과물을 만들어내기까지 리스트를 총 4개 생성한다. 다른 예를 하나 들어보자. 다음 파일로부터 내용을 읽어 가장 길이가 긴 줄의 내용을 반환하는 코드다.

```elixir
IO.inspect("#{__DIR__}/files/71k-English-uncleaned-wordlist/71k English wordlist.txt")
```

```elixir
IO.inspect(
  File.read!("#{__DIR__}/files/71k-English-uncleaned-wordlist/71k English wordlist.txt")
  |> String.split()
  |> Enum.max_by(&String.length/1)
)
```

~예시에서는 사전에 수록된 단어 목록을 사용했는데.~ 현재 예시는 `huggingface.co/datasets`에서 가져온 데이터로 테스트했다. 가장 긴 단어를 찾기 위해 데이터 전체를 메모리에 올리고 리스트로 만들었다.

앞서 . 본두가지 예시 모두 답을 찾을 . 수있으나 이상적인 풀이는 아니다. `Enum` 모듈의 함수들은 스스로 완결성을 가지기 때문이다. 각 호출이 컬렉션을 받아 다른 완성된 컬렉션을 반환한다. 대신 컬렉션의 각 항목을 필요할 때만 가져와 처리할 . 수있다면 좋을 것이다. 그러면 연산 도중 결과를 완성된 컬렉션으로 갖고 있을 필요 없이, 원본 컬렉션의 각 값에 함수를 차례로 적용하기만 하면 된다. 스트림이 바로 . 그 역활을 한다.

## 10.2.1 스트림 조합하기

스트림을 만드는 간단한 예를 하나 보자.

```elixir
Stream.map([1, 3, 5, 7], &(&1 + 1))
```

같은 리스트에 `Enum.map`을 호출하면 `[2, 4, 6, 8]`이라는 결과를 즉시 얻을 . 수있다. 위 예제에서는 대신 스트림 값이 반환되는데, 이. 스트림에는 컬렉션에 수행해야 할 연산의 명세가 포함된다. 그렇다면 스트림에서 실제 결과를 받아오려면 어떻게 해야할까? 이 스트림을 컬렉션으로 생각하고 `Enum` 모듈의 함수에 넣으면 된다.

```elixir
s = Stream.map([1, 3, 5, 7], &(&1 + 1))
Enum.to_list(s)
```

스트림 역시 `Enummerable` 프로토콜을 구현한 타입이므로 `Stream` 모듈의 함수에 컬렉션 대신 스트릠을 전달할 수도 있다. 따라서 스트림을 조합해 사용할 수 있다.

```elixir
squares = Stream.map([1, 2, 3, 4], &(&1 * &1))
plus_ones = Stream.map(squares, &(&1 + 1))
odds = Stream.filter(plus_ones, fn x -> rem(x, 2) == 1 end)
Enum.to_list(odds)
```

물론 이코드는 다음과 같이 정리할 수 있다.

```elixir
[1, 2, 3, 4]
|> Stream.map(&(&1 * &1))
|> Stream.map(&(&1 + 1))
|> Stream.filter(fn x -> rem(x, 2) == 1 end)
|> Enum.to_list()
```

스트림은 중간 결과를 담은 리스트를 만들지 않는다. 그저 원본 컬렉션의 각 값을 연속된 연산에 차례로 태울 뿐이다. 앞에 출력된 스트림 값이 스트림의 동작을 이해하는 실마리가 된다. 조합된 스트림은 함수의 리스트로 표현되어, 실제로 연산이 수행될 때컬렉션의 각 항목에 차례로 적용된다.

리스트에만 스트림을 사용할 수 있는 것은 아니다. 많은 엘릭서 모듈이 스트림을 지원한다. 가장 긴 단어를 찾는 예제를 스트림을 이용해 다음처럼 고칠 수 있다.

```elixir
File.open!("#{__DIR__}/files/71k-English-uncleaned-wordlist/71k English wordlist.txt")
|> IO.stream(:line)
|> Enum.max_by(&String.length/1)
```

이 코드의 핵심은 `IO.stream` 함수다. 이 함수는 IO 디바이스(열린 파일)를 줄 단위로 값을 제공하는 스트림으로 바꿔준다. 이런 구현 방식은 대단히 유용해서, 두 함수를 줄인 단축 함수도 제공된다.

```elixir
File.stream!("#{__DIR__}/files/71k-English-uncleaned-wordlist/71k English wordlist.txt")
|> Enum.max_by(&String.length/1)
```

중간 결괏값을 저장하지 않는다는 점은 장점이지만 실행 시간은 원래 구현보다 두 배 정도 느려진다. 하지만 데이터가 다른 서버나 외부 센서(예를 들면 온도계)로 부터 올 때는 괜찮은 구현이다. 데이터가 천천히 들어오거ㅏㄴ 끝없이 들어올 수도 있기 때문이다. `Enum`으로 구현하면 데이터가 모두 들어올 때까지 기다려야 하지만, 스트림을 이용하면 데이터가 들어올 때마다 처리할 수 있다.
