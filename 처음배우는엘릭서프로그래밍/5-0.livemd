# 익명함수

## Section

이 장에서 살펴볼 내용은 다음과 같다.

* 익명 함수
* 인자 패턴 매칭
* 고계 함수
* 클로저
* & 함수 리터럴

엘릭서는 함수형 언어이므로 함수가 기본 타입이라는 것이 그리 놀라운 일은 아니다. fn 키워드로 익명 함수를 만들 수 있다.

<!-- livebook:{"continue_on_error":true} -->

```elixir
fn
  parameter - list -> body
  parameter - list -> body(...)
end
```

`fn...end`를 문자열 리터럴을 감싸는 따옴표 같은 것이라고 여기되, 문자열 대신 함수를 반환하는 문법이라고 생각해보자. 우리는 어떻게 만든 '함수'라는 값을 다른 함수에 전달할 수있다. 당연히 함수에 인자를 넣어 호출할 수도 있다.

함수는 기본적으로 파라미터 목록과 함수 본문을 가지며, 둘은 `->` 기호로 구분된다. 예를 들어보자. 다음 코드는 함수를 정의한 뒤 `sum`이라는 변수에 바인딩하고, 그 함수를 호출한다.

```elixir
sum = fn a, b -> a + b end
sum.(1, 2)
```

첫 번째 줄에서 a와 b라는 두 파라미터를 받는 함수를 만들었다. 함수 구현은 `->` 기호 뒤에 이어진다(예시에서는 파라미터로 받은 a와 b를 더하는 간단한 연산이다). `end` 키워드로 구현을 끝내고, 이렇게 만든 함수를 `sum`변수에 저장했다.

코드의 둘때 줄에서는 `sum.(1,2)`로 함수를 호출했다. 온점(.)을 사용해 함수를 호출하고, 괄호 안에 인자를 넣어 전달할 수 있다(나중에 살펴보겠지만 익명 함수와 기명 함수는 호출 방법이 각각 다르다. 기명함수를 호출할 때는 온점을 사용하지 않는다). 익명 함수에서는 함수가 인자를 받지 않더라도 괄호를 사용해 호출해야 한다.

```elixir
greet = fn -> IO.puts("Hello") end
greet.()
```

하지만 함수를 정의할 떄 괄호가 필요하지 않다.

```elixir
f1 = fn a, b -> a * b end
IO.puts(f1.(5, 6))
f2 = fn -> 99 end
IO.puts(f2.())
```
