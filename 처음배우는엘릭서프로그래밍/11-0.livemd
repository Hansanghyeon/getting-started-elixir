# 처음배우는 엘릭서 프로그래밍

## 11. 문자열 과 바이너리

이 장에서 살펴볼 내용은 다음과 같다.

* 문자열과 문자열 리터럴
* 문자 리스트(작은따옴표 리터럴)
* 패턴매칭과 문자열 처리

그 동안 문자열을 사용하기는 했지만 자세히 살펴보지는 않았으니 이번 장에서 짚고 가도록 하자.

## 11.1 문자열 리터럴

엘릭서에는 두 종류의 문자열이 있다. 하나는 작은따옴표로 감싼것이고 다른 하나는 큰따옴표로 감싼것이다. 둘은 내부 구현이 매우 다르지만 공통점도 많다. 양쪽 모두 다음과 같은 특징이 있다.

* UTF-8 인코딩된 문자를 저장할 수 있다.
* 이스케이프 문자를 포함할 수 있다.

| 이스케이프문자 | 이스케이프문자 |
| --------------------- | --------------------- |
| \a                    | BEL (0x07)            |
| \b                    | BS (0x08)             |
| \d                    | DEL (0x7f)            |
| \e                    | ESC (0x1b)            |
| \f                    | FF (0x0c)             |
| \n                    | NL (0x0a)             |
| \r                    | CR (0x0d)             |
| \s                    | SP (0x20)             |
| \t                    | TAB (0x09)            |
| \v                    | VT (0x0b)             |
| \uhhh                 | 1~6자리 hex         |
| \xhh                  | 2자리 hex           |

* `#{...}` 문법으로 엘릭서 표현식을 삽입할 수 있다.

```
name = "dave"
IO.puts "Hello, #{String.capitalize name}!"
```

<!-- livebook:{"break_markdown":true} -->

### 11.1.1 히어독스

모든 문자열은 여러 줄로 늘어날 수 있다. 문자열을 출력할 때는 `IO.puts`와 `IO.write`라는 두 함수를 사용할 수 있는데, `puts`는 항상 줄바꿈을 추가한다. 이 절에서 여러 줄인 문자열을 출력할 때는 줄바꿈을 추가하지 않는 `write` 함수를 사용한다.

```elixir
IO.puts("start")
IO.write("
  my
  string
")
IO.puts("end")
```

여러 줄 문자열의 앞뒤 줄바꿈, 줄간 위치한 줄의 들여쓰기가 그대로 유지되었다. **히어독스(heredocs)** 표기법은 이러한 문제를 해결해준다. 다음처럼 문자열 구분자를 세 번 입력하고(''' 또는 """) 내용의 들여쓰기에 맞추어서 닫는 구분자를 넣어주면 된다.

```elixir
IO.puts("start")

IO.write("""
my
string
""")

IO.puts("end")
```

히어독스는 함수나 모듈의 문서를 추가할 때 많이 사용한다.

<!-- livebook:{"break_markdown":true} -->

### 11.1.2 시길

루비와 비슷하게, 엘릭서는 일부 리터럴에 대한 대체 문법을 제공한다. 그중 하나로, 4.2.5절에서 살펴봤듯이 `~r{...}`로 정규식을 생성할 수 있다. 이와 같이 `~`로 시작하는 리터럴을 엘릭서에서는 **시길(sigil)**이라 부른다.

시길은 틸드(~)로 시작하며 영문 대문자나 소문자 중 한 글자, 구분자로 싸인 내용, 부가적인 옵션이 차례로 이어진다. 구분자는 `<...>` `{...}` `[...]` `(...)` `|...|` `/.../` `"..."` `...` 등이 될 수 있다. 틸드 뒤에 오는 문자는 시길의 종류를 결정한다.

<table>
  <tr>
    <td>~C</td>
    <td>이스케이프 또는 문자열 삽입을 수행하지 않는 문자 리스트</td>
  </tr>
  <tr>
    <td>~c</td>
    <td>이스케이프 및 문자열 삽입을 수행하는 문자 리스트로, 작은따옴표(') 문자열과 같음</td>
  </tr>
  <tr>
    <td>~D</td>
    <td>yyyy-mm-dd 형식의 날짜로, 타입은 Date</td>
  </tr>
  <tr>
    <td>~N</td>
    <td>yyyy-mm-dd hh:mm:ss[,ddd] 형식의 NaiveDateTime</td>
  </tr>
  <tr>
    <td>~R</td>
    <td>이스케이프 또는 문자열 삽입을 수행하지 않는 정규식</td>
  </tr>
  <tr>
    <td>~r</td>
    <td>이스케이프 및 문자열 삽입을 수행하는 정규식</td>
  </tr>
  <tr>
    <td>~S</td>
    <td>이스케이프 또는 문자열 삽입을 수행하지 않는 문자열</td>
  </tr>
  <tr>
    <td>~s</td>
    <td>이스케이프 및 문자열 삽입을 수행하지는 문자열로, 큰따옴표(") 문자열과 같음</td>
  </tr>
  <tr>
    <td>~T</td>
    <td>hh:mm:ss[,dddd] 형식의 시간으로 타입은 Time</td>
  </tr>
  <tr>
    <td>~U</td>
    <td>ISO-8601 형식의 날짜로, 타입은 DateTime</td>
  </tr>
  <tr>
    <td>~W</td>
    <td>공색 문자로 값을 구분하는 리스트로, 이스케이프 또는 문자열 삽입을 수행하지 않음</td>
  </tr>
  <tr>
    <td>~w</td>
    <td>공백 문자로 값을 구분하는 리스트로, 이스케이프 및 문자열 삽입을 수행함</td>
  </tr>
</table>

다음은 다양한 구분자를 사용하 시길의 예시다.

```elixir
IO.puts(~C[1\n2#{1+2}])
```

```elixir
IO.puts(~c"1\n2#{1 + 2}")
```

```elixir
IO.puts(~S[1\n2#{1+2}])
```

```elixir
IO.puts(~s/1\n2#{1 + 2}/)
```

```elixir
IO.inspect(~W[the c#{'a'}t sat on the mat])
```

```elixir
IO.inspect(~w[the c#{~c"a"}t sat on the mat])
```

```elixir
IO.puts(~D<1999-12-31>)
```

```elixir
IO.puts(~T[12:34:56])
```

```elixir
IO.puts(~N{1999-12-31 23:59:59})
```

`~W`와 `~w` 시길은 옵션으로 a, c, s를 받는다. 이 옵션은 값을 아톰, 문자 리스트, 문자열 중 무엇으로 반환할지를 결정한다. `~r` 시길의 옵션은 정규식에서 살펴봤다.

내용을 감싸는 구분자는 '단어가 아닌(noword)' 문자라면 무엇이든 괜찮다. 괄호 종휴 `(` `[` `{` `<` 로 시작했다면 그에 대응하는 닫힘 문자를 종료 구분자로 사용해야 한다. 구분자가 활호가 아니라면 이스케이프되지 않은 상태로 두 번째로 나오는 시작 구분자가 종료 구분자가 된다. 엘릭서는 구분자의 중첩을 확인하지 않는다. 따라서 `~s{a{b}`와 같은 시길은 `a{b`라는 세글자 짜리 문자열이 된다. 만약 시작 구분자가 작은따옴표나 큰따옴표 세 개면, 이 시길은 히어독스로 취급된다.

```elixir
IO.inspect(~w"""
the
cat
sat
""")
```

히어독스 시길에 옵션을 넣고 싶을 때도 (대부분 `~r`을 사용할 때다) 마찬가지로 종료 구분자 뒤에 넣어주면 된다.

```elixir
IO.inspect(~r"""
hello
"""i)
```

흥미록게도 시길을 직접 만들 수도 있다. 자세한 내용은
